-- 관계형 데이터베이스의 테이블은 정규화라는 기법을 사용해 설계한다. 정규화로 설계된 테이블 각각은 하나의 독립된 추제를 담는다. 예를 들어 고객 테이블에는 고객 정보만, 주문 테이블에는 주문 정보만
-- 관리한다. 독립된 주체를 가진 테이블은 조인을 사용해 연결할 수 있으면, 조인된 결과는 더 가치 있는 정보를 제공할 수 있다.

-- 조인을 사용하면 안 된다고 주장하는 사람도 있다. 아래와 같은 이유다.
-- * 조인하면 결과가 무조건 맞지 않아. -> 조인을 정확히 사용하면, 설계가 잘못되지 않은 이상 부정확한 결과가 나올 일은 없다. 조인을 다시 익힐 필요가 있다.
-- * 조인하면 성능이 안 좋아. 너무 느려 -> SQL 성능에는 다양한 원인이 있다. 조인 때문에 성능이 나쁘다고 단정하기는 어렵다. 조인을 안 쓰기 시작하면 데이터의 중복이 늘어난다. 이로인해 전체 성능이 나빠질 수 있다.

-- 정규화를 주장하는 것이 아니다. 성능과 개별 편의를 위해, 적절한 반정규화를 필요하다. 다만, 위와 같은 이유로 무작성 조인을 피하려고 해서는 안된다.
-- 조인을 사용해야 테이블 정보가 빛을 발한다. 독립된 정보를 연결해 통합된 정보가 나올 때, 업무적인 가치가 올라간다.


-- 2.1 INNER-JOIN
-- 2.1.1 INNER-JOIN 이해하기

-- 조인에는 세 가지 방법이 있다. INNER-JOIN, OUTER-JOIN, CARTESIAN-JOIN이 그 세 가지다.

-- 보통 조인이라하면 INNER-JOIN을 뜻한다. INNER-JOIN은 조건을 만족하는 데이터만 결합해 결과로 내보낸다.

-- SQL의 WHERE 절에 사용하는 조건은 '필터 조건'과 '조인 조건' 두 가지가 있다. FROM 절에 사용된 테이블이 하나면 필터 조건만 존재한다.
-- 반면에 FROM절에 사용된 테이블이 두 개 이상이면 필터와 조인 조건이 동시에 있을 수 있다.

-- INNER-JOIN의 특징
-- - 조인 조건을 만족하는 데이터만 결합되어 결과에 나올 수 있다.
-- 한 건과 MANY건이 조인되면 MAMY건의 결과가 나온다.

-- 실제 테이블을 이용한 INNER-JOIN SQL을 살펴보자.

SELECT T1.CUS_ID, T1.CUS_GD, T2.ORD_SEQ, T2.CUS_ID, T2.ORD_DT
FROM M_CUS T1
	 , T_ORD T2
WHERE T1.CUS_ID = T2.CUS_ID
AND   T1.CUS_GD = 'A'
AND   T2.ORD_DT >= TO_DATE('20201202', 'YYYYMM')
AND   T2.ORD_DT < TO_DATE('20201111', 'YYYYMM')

-- - 조인 조건(4번 라인) WHERE T1.CUS_ID = T2.CUS_ID
-- - T1 필터 조건(5번 라인) AND   T1.CUS_GD = 'A'
-- - T2 필터 조건(6, 7번 라인) 범위

-- INNER-JOIN의 처리 과정
-- 1. M_CUS에서 CUS_GD가 A인 데이터만 찾아낸다.
-- 2. M_CUS의 첫 번째 로우인 CUS_1과 같은 CUS_ID가 T_ORD에 있는지 검색한다.
-- 필터 조건을 만족한 데이터만 조인에 참여한다. 그리고 조인 조건을 만족한 데이터만 결과에 나올 수 있다.

-- INNER-JOIN의 처리 과정 - 뒤 바뀐 접근 순서
-- 두 데이터 집합 간에 조인이 이루어질 때, 테이블의 접근 순서나 조인의 처리 순서는 조인 결과에 전혀 영향을 주지 않는다. 


-- 2.1.2 여러 테이블의 조인
-- 시스템을 개발하다 보면 하나의 SQL에 여러 테이블이 조인되는 경우가 수두룩하다. 
-- 여러 테이블을 조인한다고 겁먹을 필요 없다. 두 개의 테이블이 조인되는 과정과 개념만 정확히 이해하면 열 개든 백 개든 문제없다.
-- 아무리 많은 테이블이 조인되어도 결국은 두 테이블의 조인을 계속하는 것에 불과하다.
-- 여러 테이블의 조인을 잘하기 위해서는 조인을 테이블과 테이블 간의 연결이 아니라, '테이터 집합'과 '데이터 집합'간의 연결이라고 생각을 바꿔야 한다.

-- - 테이블 자체를 데이터 집합으로 볼 수 있다.
-- - WHERE절의 필터 조건을 거친 결과를 데이터 집합이라 할 수 있다.
-- - 두 개의 데이터 집합이 조인된 결과는 새로운 하나의 데이터 집합이다.

-- 조인은 데이터 집합과 데이터 집합 간의 연결이다.
-- A, B, C 3개의 테이블 조인한다고 생각해 보자. A와 B가 먼저 조인이 수행되어 새로운 데이터 집합 AB가 만들어진다.
-- AB가 C와 조인이 수행되면 최종 결과인 ABC가 만들어진다.

-- A와 B가 조인된 AB는 물리적인 테이블이 아닌 두 개 테이블이 연결된 새로운 데이터 집합이다.
-- 즉 C 테이블은 AB 데이터 집합과 조인한다.
-- 좀 더 유연하게 테이블 자체도 데이터 집합으로 생각할 수 있다. C 테이블이 아닌 C 데이터 집합과 AB 데이터 집합이 조인한다고 이해하면 된다.

-- 테이블 간의 관계를 파악하는 것도 조인에 큰 도움이 된다. 테이블 간의 관계를 파악하기 위해서는 ERD가 필요하다. 자신이 개발하는 부분의 ERD는 수시로 볼 수 있게 준비해 놓는 것이 좋다.
-- 모든 ERD에 관계가 그려져 있는 것은 아니다. ERD에 관계가 없다 해도 업무적으로 관계는 존재하낟. 업무적인 관계를 이해하고 조인을 작성해야 한다.

-- 여러 테이블을 조인할 때는 아래 내용을 기억해야 한다.
-- - 한순간에는 두 개의 데이터 집합에 대해서만 조인이 발생한다.
-- - 조인이 이루어진 두 개의 데이터 힙합은 새로운 하나의 데이터 집합이다.
-- - 테이블 간의 관계를 이해하고 조인을 작성하자.


-- 2.1.3 잘 못 작성한 조인(M:1:M 조인)
-- 복잡하고 긴 SQL을 검토하다 보면 조인을 잘못 작성한 경우가 간혹 있다. 이때 전형적으로 등장하는 것이 바로 뜬금없는 DISTINCT이다. 몇 개의 테이블을 조인하다 보니, 중복된 데이터가 나와
-- DISTINCT를 사용해 강제로 중복을 제거한 경우다.
-- 이처럼 잘 못 장성된 SQL이 나오게 되는 예를 살펴보자.

-- 먼저 1:1, 1:M과 같은 관계 차주세 따로 조인 결과 건수를 알아보자.

-- - 1:1 관계 조인 = 1건의 결과 발생
-- - 1:M 관계 조인 = M건의 결과 발생
-- - M:M 관계 조인 = M*M건의 결과 발생

-- 위에서 M:M 관계는 다대다 관계를 뜻한다. M:M 관계의 조인은 OLTP 환경에서는 발생할 일이 거의 없다. 정확하게는 OLTP에서 M:M 관계가 있어서는 안 된다.
-- M:M 조인이 발생한다면 테이블 설계에 문제가 있거나 조인을 수행해서는 안 되는 대상임을 의심해야 한다.

-- M:1:M의 관계는 조인이 아닌 UNION ALL을 사용하거나 M:1을 먼저 1로 만든 후 나머지 조인을 해야 한다. 

-- M:1:M의 조인 해결 - UNION ALL을 사용

-- 2.1.4 RANGE-JOIN
-- 대부분의 조인은 같다 조건을 이용한다. 하지만 반드시 같다 조건으로만 조인을 할 수 있는 것은 아니다. 범위 조건을 줄 수도 있으며 떄에 따라서는 같지 않다를 사용할 수도 있다.



-- 2.2 OUTER-JOIN
-- 2.2.1 OUTER-JOIN 이해하기
-- INNTER-JOIN은 조인 조건에 만족한 데이터만 결과에 나올 수 있다. 반면에 OUTER-JOIN은 조인 조건에 만족하지 않은 데이터도 결과에 나온다. 
-- OUTER-JOIN을 설명하기 위해 '기준 데이터 집합'과 '참조 데이터 집합'이란 용어를 정의하도록 하겠다.
-- - 기준 데이터 집합: 아우터-조인이의 기준이 되는 집합(아우터 집합이라 한다.)
-- - 참조 데이터 집합: OUTER-JOIN의 참조가 되는 집합

-- 기준 데이터 집합은 조인 조건을 만족하지 않아도 모두 결과에 포함된다. 단, 필터 조건은 만족해야 한다.
-- OUTER-JOIN을 사용하려면, 조인 조건 컬럼 한쪽에 + 표시를 추가하면 된다. 조인 조건에 +가 있으면 OUTER-JOIN, 없으면 INNER-JOIN이다.
-- 기준 데이터 집합과 참조 데이터 집합은 +표시로 구분한다. 조인 조건에 + 표시가 붙은 쪽은 참조 데이터 집합 + 표시가 없는 쪽은 기준 데이터 집합이다.

-- INNER-JOIN
SELECT T1.CUS_ID
	 , T1.CUS_NM
	 , T2.CUS_ID
	 , T2.ITM_ID
	 , T2.EVL_LST_NO
FROM  M_CUS T1
	, T_ITM_EVL T2
WHERE T1.CUS_ID = 'CUS_0002'
AND T1.CUS_ID = T2.CUS_ID;

-- OUTER-JOIN
SELECT T1.CUS_ID
	 , T1.CUS_NM
	 , T2.CUS_ID
	 , T2.ITM_ID
	 , T2.EVL_LST_NO
FROM  M_CUS T1
	, T_ITM_EVL T2
WHERE T1.CUS_ID = 'CUS_0002'
AND T1.CUS_ID = T2.CUS_ID(+);


-- 2.2.2 OUTER-JOIN의 필터 조건
-- OUTER-JOIN에서는 참조 데이터 집합의 필터 조건에서도 (+) 표시를 추가해야 한다.
-- 참조 쪽 필터 조건에(+) 사용: OUTER-JOIN 전에 필터 조건이 사용된다.
-- 참조 쪽 필터 조건에(+) 미사용: OUTER-JOIN 후, 조인 결과에 필터 조건이 사용된다.


-- 2.2.3 실행이 불가능한 OUTER-JOIN
-- OUTER-JOIN에서 + 표시가 된 참조 데이터 집합은 두 개 이상의 기준 데이터 집합을 동시에 가질 수 없다. 


-- 2.2.4 OUTER-JOIN의 응용
-- OUTER-JOIN은 조인에 성공하지 못해도 기준 데이터 집합은 무조건 조회되는 특징이 있다. 이와 같은 특징은 분석 리포트에서 실적이 없는 마스터도 결과에 포함시킬 때 유용하다.

-- OUTER-JOIN 정리
-- OUTER-JOIN은 기준 데이터 집합과 참조 데이터 집합으로서 조인이 이루어진다.
-- 참조 데이터 집합은 조인 조건에 (+)가 표시된 쪽이며 반대쪽은 기준 데이터 집합이 된다.
-- 기준 데이터 집합은 조인 조건을 만족하지 않아도 필터 조건만 만족하면 결과가 나온다.
-- 참조 데이터 집합의 필터 조건에 +를 표시하면 OUTER-JOIN 전에 필터가 된다.
-- 참조 데이터 집합의 필터 조건에 +를 표시하지 않으면 아우터 조인 후 필터가 된다.
-- 일반적으로 참조 데이터 집합의 필터 조건에는 +를 표시한다.
-- 참조 데이터 집합이 다른 집합과 조인될 때는 기준 집합으로서 OUTER-JOIN해야 한다. 



-- 2.3 CARTESIAN-JOIN
-- 2.3.1 CARTESIAN-JOIN 이해하기

-- 묻지마 조인이라고 한다. 조인 조건이 없는 조인을 뜻한다. 이를 CARTESIAN-JOIN이라 한다.

-- 2.3.2 CARTESIAN-JOIN의 위험성
-- CARTESIAN-JOIN은 매우 위험한 조인이다. 실수로 CARTESIAN-JOIN이 발생하면 시스템 장애가 일어날 수도 있다.

-- 2.3.3 분석마스터 만들기
-- CARTESIAN-JOIN은 분석 마스터를 만들 때 유용하다.

-- 2.3.4 테스트 데이터 만들기
-- 대량의 테스트 데이터를 만들기 위해 CARTESIAN-JOIN을 활용할 수 있다. 